##序言
python 中对象的三要素是 id（地址）；type（数据类型）；value（值）
"=="是比较值，"is"是比较地址
print(sep)	sep是分隔字符串默认''	如print('cat''dog''mice',sep=',')
>>>cat,dog,mice
多行连续输入：
用（）或 \:在多行输出长字符串时用\较好
	       is_leap = year % 4 == 0 and year % 100 != 0 or \
           year % 400 == 0
	       is_leap = （year % 4 == 0 and year % 100 != 0 or 
           year % 400 == 0）	
print()方法 
	两个print（）前一个中的参数end= ""("\n")决定下一个print()的输出内容是接着上一行还是换行
对于获得的数字类型的数据，最好用对应的函数转化一下具体数字类型，这样输入也能好看一点
print(str1,str2,str3)多个输出.print（"{}".format(1),"{}".format(2)）这样也可以.
	if __name__ == '__main__' :           在一个模块A中写上这句话有什么作用？
作用：  __name__的含义是模块的名字，运行模块A时，A的名字就叫做'__main__'；但从B模块中导入时，A的名字不叫'__main__'而叫'A'
故模块A中加上这一段话意思是:直接运行模块A，if下的代码块有效，导入模块A，if 下的代码块效。 				
python help用法：
	只能查看内置函数.

序列解包：
		#1   d = 1,2,3	#2   a,b,c = [1,2,3]    序列有元组，列表，字典  class "d" = <tuple>
		       a,b,c = d	

命名：尽量不用下划线，可用schoolstudent 而变量命名多用下划线school_student


##列表/字符串方法
	s[起始:终止:步长] 注：三者均可正可负，步长为负意味反向切片,起始到终止的关系是:  [a,b) 
	s = "1234"
	s[:] = "1234"   s[0:4:2] = "13" s[::-1] = "4321"
	s.index():
			index:索引，指标
			该方法查找列表中元素或字符串的子串的下标数字索引
	s.upper()/lower():大写/小写
	isX方法[验证用户输入]:
			s.isupper():    全为大写则为真，否则为反。
			s.isalpha():	非空，且只含字母，则为真。
			s.isdecimal():	非空，且只含数字，则为真。
			s.isalnum():	非空，且只含数字和字母，则为真。
	s.split(sep,maxsplit):
			sep是分隔字符串，默认空格，	  
			maxsplit是最多分隔的次数。
	s.join(iterable):将一个字符串列表连接成字符串，iterable是列表，s是
			字符串列表的相邻项之间的连接字符。
			注意！！！是字符串列表！！！
	s.rjust(width,fillchar):
			width 本意宽度，这里指长度，即将s放入一个width
			的字符串向右对齐。
			fillchar 在width长度的字符串中，除s外，剩余部分
			的填充字符串。
			相应的有s.ljust() s.center() 参数相同
	s.lstrip():删除左边的空字符，rstrip()删除右边的空字符。
					
	str in dict :in 操作符检查字典的键的列表中是否有字符串。
	字符串分类:
			转义字符串:
					\\表示 \ ;\t表示 制表符;
			原始字符串:
					即字符串的输入照搬到屏幕，不会出现转义
					str1 = r'Hello\nWorld'即表示Hello\nWorld
					而不是	 		 Hello
									World
			多行字符串:
					用''' '''
					即'''hello 
								world'''  ;
					用\
						'hello \
								world'	。


##循环
	
	类真与类假
			其他数据类型的值，条件认为他们等价于True or False
			如0，0.0，''	while '':  <==> while False :	这称之为"类假"
			而除此之外的值会默认为True  如	while 3: <==> while True:	这称之为"类真"
		
	while循环:
			while True:
			else:
			无条件循环 即死循环配合break，continue
			break只能跳出一层循环
			Ctrl + C 强行退出While循环
思考:如何重复执行程序？

注意 if...else 与for...else 和 while...else的不同
	if...else是如果if条件不成立，才能执行else语句块
	而for...else 和 while...else是 for 和while下的语句块正常执行完后，不需要判断条件，即可执行else语句块
	即如果有break，不会执行else语句块.如果有continue，则可以执行else语句块.
	注意！！！注意！！！
	range的逆用法:
		>>>for i in range(3,-1,-1):		[3,-1)以-1为逆步长。
		...		print(i)
		>>>3
		>>>2
		>>>1
		>>>0

##函数
	函数重载:同一个函数，给的参数不同，功能不同.
	可变参数：*args  可将之理解为一个列表.
	函数形参的默认值：
	#1 def  fun(n=3):			#2 def  fun(n):
		print("1"*n)			n = 3
					print("1"*n)
	fun()
	#1的结果是："111"                                  #2的结果是:  "111"
	但是当是fun(1)
	#1是 "1"                                                  #2是  "111"
	综上，形参的初值用方式一.

	函数是干某件事的算法集合，python中函数的返回对象不一定是一个值，可以是数值、元组、列表、甚至函数.
	最好每次有个return 如果没有return，函数值默认为None.只有一个Return则，return后的语句不会执行.类似
	break.
	Return 只能用在函数中.
	函数中返回多个值：Return A,B,C
	!!!函数一定要有返回值，不要print(),没有print()有函数值，则可以print(函数)，但是没有返回值容易出BUG，
	且不容易检测出来。
						


##模块与包
	包（文件夹）---->模块（.py文件）---->类---->函数与变量
	有两个平行的包six与seven，其下级目录中均有一个c4.py（文件）的模块，
	如何区别这两个模块呢？
		six.c4                       seven.c4  这样构成了一个路径，这种命名叫做命名空间
		包下面可以包含子包，子包与模块可以是平行的关系.如文件夹下可以有文件夹与.py文件

	包是文件夹，但文件夹不一定是包，python是如何区别包与文件夹的呢？
		注意包的下级目录下必须有一个__init__.py的文件（模块）.这个文件中可以什么都不写，也可以只当作一颗普通的
		模块写入类或函数与变量.这个模块是判断一个文件夹是不是包的依据.这个模块的名字叫six 而不是six.__init__
		即与包的名字相同.(__init__是两个下划线，c4.py名字叫做c4)
	交互式界面中，python中的包必须安装在当前工作目录下，在这个包中在创建__init__.py文件。
	如何在同一目录下相互导入python文件呢？
	from File_A import File_B
	A与B在同一目录下
	如何从其他的模块中调用函数和变量呢？
		有两种情况:文件式编程和交互式编程的情况.交互式我不太懂，故只记录
		文件式情况
		首先，确认你目前打开的文件的位置，在该位置下创建一个包(在该位置下创建一个文件夹，在该文件夹下创建一个__init__.py文件).
		再在该文件夹下创建一个模块.
		模块的两种引用方式 import 与from    import  引用的是模块， from 引用的是具体的函数或变量
			import：
			在你打开的文件中引用.
			import Module_name          or     import Module_name as M
			如果想调用变量A
			print（Module_name.a）     or       print(M.a)
			如果想调用函数
			print(Module_name.function())      print(M.function())
			综上，import方法调用时Module_name 有时太长，不方便.就用import Module_name as M 这种方式
		from：
		from Module_name import a,b,c 导入多个变量
		form Module_name import (a,b,c                           导入过多的换行问题
		d,e)
	from 上级目录 import 下级目录
	常见用法：from Module_name import Variable ,Function	
	思维拓展：from Package import Module_name
	虽然这样一来，与import没什么区别（即调用函数，都要Module_name.function()）.但可以拓展思维.
	from Module_name import * 引用该模块中的所有东西，这种引用方法指向不明，最好少用.



	package下的Module的执行顺序：
		import package 时会执行其下的所有模块的代码，__init__.py文件下的代码会首先自动执行.
		__init__.py 在导入包时(无论是只导入包还是导入包中模块中的变量)会首先执行，并且自动执行__init__.py中的代码.
	Module 与__init__.py中的 __all__ 都是在from * 这种导入方式情况下对导入的模块，变量或函数的数量的限制
		Module中的       __all__ 变量   :
				我们在用from Module_name import *时，我们可以不把所有的变量导入,可以在对应的模块中写__all__ = ['a','b','c'],这样可以限制
				from只导入Module_name中的a,b,c三个变量，而不是所有变量.(注意要加引号)
		__init__.py中的   __all__  变量  : 
				可以写__all__ = ['Module1','Module2'],也可以限制导入包中的模块，不会导入所有的包.

	有10个文件，在这10个文件中每个文件导入十个模块，怎么办？
		首先，在package的__init__.py文件中导入这十个模块，然后在十个文件中只需要import package  这样,package下的__init__.py文件会自动执行.

##类与模块
类：
	#类的定义
	类中的变量叫做数据成员,类中只含两种东西：数据成员(属性)和方法（行为）.
	类将这些数据和数据上的操作封装在一起.
	class  SchoolStudent():
		name = ""
		age = 0
		def print_file(self):
			print("1"+self.name)
	#类的实例化
	student = SchoolStudent()
	注意：	类中的函数不管加不加变量，都比需加self.(如果类中函数有必须参数，该怎么写呢？？？)
		def print_file(self,variable1,variable2):


		类中函数引用类中的变量与模块中函数引用模块中变量不同（模块中上例的情况为全局变量），类中都必需用self.variable
		函数与方法的区别：
				类中的函数叫方法，模块中的函数叫类.
	类只负责刻画描述一个对象（用变量，方法），但类不会去执行代码.
	如：
	class  SchoolStudent():
		name = ""
		age = 0
		def print_file(self):
			print("1"+self.name)
		print_file()	#这是错误的.			
	#从其他模块中引用类.最好在一个模块中专门写类
	from Module_name import class
对象：
	类是个人简历表格（模板），对象则是某个人的个人简历表.如果将一个类实例化却没有输入相应的参数，那么他不叫对象,故对象
	一定要实例化，实例化的不一定是对象.
	类的实例化：
	class  SchoolStudent():
		name = ""
		age = 0
		def __init__(self,name1,age1):		#构造函数
			name = name1		#每当对一个类实例化时，会自动调用__init__()函数，如student = Student()   则会默认执行student.__init__().
			age = age1		#构造函数只能默认返回None，不能返回除此之外的任何值(如字符串).
		def print_file(self):			#构造函数的函数体用于初始化类的属性.
			print("1"+self.name)
	student = Student("LiDong",19)
	类SchoolStudent()中什么时候可以可以输入参数？
	只有当其中 def  __init__(self,variable1):   定义了这个函数且该函数参数列表不知有self一个参数方可，
	其本质是：student = Student()
		student.__init__("LiDong")	可以这样理解，但不能这样写.	[因为类的实例化会自动调用__init__方法，而__init__又需要一个参数，故简化为student = Student("LiDong")]
	类中函数可分为三种:def m():(静态函数)；def m(self):(实例方法);def m(cls):(类函数)   其中实例方法在定义时要加self，在调用时不用加.
	类中变量可分为三种：一种是class.name(类变量)；一种是self.name(实例变量)，
			还有一种是实例输入变量（即实例方法中所获得的用户输入变量.）
			当用对象.__dict__查看实例变量是，没有name.
	一般将输入变量的值赋给实例变量，当调用实例变量时，会在实例变量列表中寻找，如果没有，会在类变量列表中寻找同名的变量.
	__dict__变量：student.__dict__表示student这一对象下所有实例变量的字典，当然SchoolStudent.__dict__表示类中所有类变量的字典.
	self含义:是当前调用某个方法的对象
	如 student1.fun()    ;student2.fun()     self分别指student1,student2.
	在实例方法中能否访问类变量？可以.
	class S():
		name = "123"
		def s(self):
			print(S.name)
	7、正则表达式
			>>> import re
			>>> #1不带()
			>>> a = re.compile(r'(\d\d)-(\d)')
			>>> mo = a.search('22-33-44')
			>>> mo.group()
			'22-3'
			>>> mo.groups()
			('22', '3')
			>>> #2带()
			>>> a = re.compile(r'((\d\d)-(\d))')
			>>> mo = a.search('22-33-44')
			>>> mo.group()
			'22-3'
			>>> mo.groups()
			('22-3', '22', '3')
			>>> #不带()
			>>> a = re.compile(r'(\d\d)-(\d)')
			>>> mo = a.findall('22-33-44-55-66')
			>>> mo
			[('22', '3'), ('44', '5')]
			>>> #带()
			>>> a = re.compile(r'((\d\d)-(\d))')
			>>> mo = a.findall('22-33-44-55-66')
			>>> mo
			[('22-3', '22', '3'), ('44-5', '44', '5')]
				在finddall()中，各级()中的元素均作为列表的项，项的索引顺序
				由外而内，由左向右，依次增大。
					>>> a = re.compile(r'((\d)-(\d(\d{2,5})))')
					>>> mo = a.findall('3-3456')
					>>> mo
					[('3-3456', '3', '3456', '456')]




	文件：
			在shelve模块打开文件时，如果只给文件名，则python解释器只在当前
			工作目录下寻找，所以一般给完整的文件路径和文件名。